---
title: "Fourth task"
author: "Akvilė Višniauskaitė ir Ieva Pudžiuvelytė"
date: "5/30/2022"
bibliography: references.bib
csl: apa-single-spaced.csl
output: pdf_document
header-includes:
- \usepackage{float}
---

# Introduction

This work will present data analysis from a research that studied the 
enchancer's at *IGF2* differential methylation association with abnormal 
dopamine synthesis in major psychosis [@pai2019differential].

Our samples were taken from the prefrontal cortex isolated neurons from patients 
with schizophrenia and bipolar disorder.

The study analysed data from individuals diagnosed with schizophrenia, bipolar
disorder, and controls (29, 26 and 27 individuals respectively).
In the analysis, study controlled for age, sex, post-mortem interval, genetic 
ancestry (determined by genotyping the same individuals).

## Experiment design

The experiment design was multi-omics study with 55 cases (with schizophrenia or
bipolar disorder) and 27 controls.

## Objective of the research

According to authors, schizophrenia and bipolar disorder have got characteristic 
of periods of psychosis. The main objective of the research was to gather 
epigenomic profiling data to get a more accurate model of neuronal 
dysregulation in diseases with periods of psychosis.

## Biological targets of the research

Researchers intended to look for specific patterns of DNA methylation in 
isolated neurons from the frontal cortex of individuals that had diseases.

- IGF2 - insulin growth factor 2 protein
- *IGF2* - IGF2 gene
- *Igf2* - enhancer of *IGF2*
- TH - tyrosine hydroxylase protein
- dopamine - a neuromodulatory molecule
- psychosis - an abnormal condition of the mind that results in difficulties 
  determining what is real and what is not real 

## Results received

Authors found a strong association between methylation of *Igf2* and TH 
synthesis. 
TH is the bottleneck enzyme that is responsible for dopamine synthesis. 
If enhancer *Igf2* is hypomethylated, levels of TH are higher, which 
determines the higher production
of dopamine. Apparently, dopamine is responsible for psychosis in the 
mental disorders of interest.

## Additional information

Schizophrenia and bipolar disorder patients are consistently hypomethylated
at *IGF2* locus when compared to controls. This locus remained significantly 
hypomethylated even after accounting lifestyle-related variables of smoking
and anti-psychotic use.

The reaction chain of interest of the research (upward arrows show elevated
expression or synthesis of the protein, product, or effect):

Hypomethylation of *Igf2* $\rightarrow$ $\uparrow$ IGF2 $\rightarrow$ 
$\uparrow$ TH $\rightarrow$ $\uparrow$ dopamine $\rightarrow$ $\uparrow$ 
psychosis

# Data preparation

```{r include=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE, fig.pos='!H')
```

```{r include=FALSE, eval=FALSE}
#BiocManager::install("minfi")
#BiocManager::install("IlluminaHumanMethylationEPICmanifest")
#BiocManager::install("IlluminaHumanMethylationEPICanno.ilm10b4.hg19")
```

```{r include=FALSE, eval=FALSE}
library(minfi)
library(IlluminaHumanMethylationEPICmanifest)
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
```

```{r include=FALSE}
sample_keys <- read.csv('../data/GSE112179_RAW/GSE112179.csv')

# Basename
sample_keys$Basename <- paste('../data/GSE112179_RAW/', sample_keys$Basename, 
                              sep='')
(sample_keys$Basename)

# Unknown values
sample_keys$pmi[sample_keys$pmi == "unknown"] <- NA_real_
sample_keys$pmi[sample_keys$pmi == "?"] <- NA_real_
sample_keys$race[sample_keys$race == "?"] <- NA_character_

# Lower case
sample_keys$race <- tolower(sample_keys$race)
sample_keys$sex <- tolower(sample_keys$sex)
sample_keys$diagnosis <- tolower(sample_keys$diagnosis)
```

Sample keys heading is made of the following columns names:

- *id* - an identifier of the sample
- *sentrix_id* - Illumina's Sentrix BeadChip identifier 
  (13 unique values) 
  [@imatsentrix]
- *sentrix_row* - row number in the Sentrix array
- *sentrix_col* - column number in the Sentrix array
- *basename* - sample identifier in the research (joined values in a format:
  \newline [\textit{id}]_[*sentrix_id*]_R0[*sentrix_row*]C0[*sentrix_id*])
- *tissue_bank_id* - an identifying number of the tissue bank from which the 
  sample was taken
- *tissue_bank* - the literal identifier of the tissue bank
- *tissue* - a tissue type from which the sample was taken
- *cell_type* - a cell type found in the sample
- *donor* - an integer number that identifies the donor of the sample 
  (82 unique values)
- *pmi* - a post-mortem interval, unknown values 
  were labeled as NA
- *race* - race of the donor (white, black, hispanic, or unknown (NA))
- *sex* - gender of the donor
- *diagnosis* - an experimental group of the donor (bipolar, schizophrenia, or
  control)
- *age* - age of the donor (years)
  
As it was noted in the article, there were 100 records in the sample keys 
dataset.

```{r include=FALSE, eval=FALSE}
# Reading IDAT data
rgcs <- read.metharray.exp(targets=sample_keys)
```

```{r include=FALSE, eval=FALSE}
# Saving RGChannelSet object data to file 
rgcs_location <- '../data/GSE112179_RGCS.rgcs'
saveRDS(rgcs, file='../data/GSE112179_RGCS.rgcs')
```

```{r include=FALSE, eval=FALSE}
# Loading RGChannelSet object to RAM.
RGSet <- readRDS(file=rgcs_location)
```

## Calculating detection p-values

Getting detection p-value for each score of DNA modification. These p-values
determine whether the measured intensity can be distinguished from the 
background.

```{r include=FALSE, eval=FALSE}
# Getting detection p values as matrix
detP <- detectionP(RGSet)

# Converting matrix to a data frame
detP_f <- data.frame(detP)
```

All values that have got p-value higher than 0.01 are considered as bad and 
all samples that have more than 1% of bad detection p-values should be removed.

```{r include=FALSE, eval=FALSE}
# Columns determine samples, rows define location of modification

# Calculating how many values compose one percent
one_perc <- round(nrow(detP) / 100)

# Looping over columns (samples)
for(i in 1:ncol(detP_f)) {    
  higher_p <- 0
  # Looping over p values of each sample
  for(p in detP_f[ , i]){
    # p value higher than 0.01 is considered as bad
    if(p > 0.01){
      higher_p <- higher_p+1
    }
  }
  # Getting sample names for removal
  if(higher_p > one_perc){
    print(colnames(detP_f)[i]) 
  }
}
```

Although, in our data, none of the samples had more than 1% of bad values, 
therefore no 
sample was removed.

## Predicting sample sex

This stage estimates sample sex based on methylation data.

```{r include=FALSE, eval=FALSE}
GMSet <- mapToGenome(RGSet)
RGSet_est_sex <- getSex(GMSet)
```

Number of females and males after estimation matched original data (25 female 
and 75 male).

Converted 'M' and 'F' notation to 'male' and 'female'.

```{r include=FALSE, eval=FALSE}
RGSet_est_sex$predictedSex[RGSet_est_sex$predictedSex == 'M'] <- 'male'
RGSet_est_sex$predictedSex[RGSet_est_sex$predictedSex == 'F'] <- 'female'
```

```{r include=FALSE, eval=FALSE}

bad_samples <- list()

# Looping over each position
for(i in 1:length(RGSet_est_sex$predictedSex)) {    
  if(RGSet_est_sex$predictedSex[i] != RGSet$sex[i]){
    bad_samples[[length(bad_samples)+1]] <- rownames(RGSet_est_sex)[i]
  }
}

bad_sample
```

No mismatches between real and estimated sex were found.

## Data normalisation

According to the documentation of *minfi* package [@fortin485512analysis], 
*preprocessFunnnorm()* function is recommended for known large-scale differences
(for example, cancer/normal) or between-tissue studies. Our chosen data 
spans only over one cell type of one tissue, therefore it was decided to opt for
different normalisation methods.

Authors [@pai2019differential] noted
that they used noob normalisation followed by the quantile one. Quantile 
normalisation performs processing of Type I and Type II array design 
differences. Whereas, *preprocessIllumina()* normalisation has only background 
subtraction 
and control normalisation implemented. Therefore, we decided to choose 
*preprocessSWAN()* normalisation, since this method performs within-array 
normalisation correction for technical differences between Type I and Type II 
array designs.

```{r include=FALSE, eval=FALSE}
set.seed(1)
MSet.swan <- preprocessSWAN(RGSet)
```

## Filtering position data by detection p-values

```{r include=FALSE, eval=FALSE}
# Columns determine samples, rows define location of modification

# Calculating how many values compose one percent
one_perc_samples <- round(ncol(detP) / 100)

bad_positions <- list()
# Looping over each position
for(i in 1:nrow(detP_f)) {    
  higher_p <- 0
  # Looping over p values of each position
  for(p in detP_f[i, ]){
    # p value higher than 0.01 is considered as bad
    if(p > 0.01){
      higher_p <- higher_p+1
      if(higher_p > one_perc_samples){
        bad_positions[[length(bad_positions)+1]] <- rownames(detP_f)[i]
        break
      }
    }
  }
}
```

There were 5835 positions found that had p-value higher than 0.01 in 1% of the
samples. These positions were removed from the dataset. After this procedure,
we have 861001 positions in each sample.

```{r include=FALSE, eval=FALSE}
length(unique(bad_positions))
MSet.swan <- MSet.swan[!(row.names(MSet.swan) %in% bad_positions), ]
```

```{r include=FALSE, eval=FALSE}
intermed_file_loc <- '../data/GSE112179_MSet_SWAN_clean.rds'
```

```{r include=FALSE, eval=FALSE}
saveRDS(MSet.swan, file=intermed_file_loc)
```

## Removing methylation loci positions

```{r include=FALSE, eval=FALSE}
MSet.swan <- dropMethylationLoci(MSet.swan, dropRS = TRUE, dropCH = TRUE)
```

2918 methylation loci that do not contain "CG" nucleotide 
pair (CH probes) or are close to DNR polymorphisms were removed. After the 
removal data contained 858083 positions in each sample.

## Making three different data objects

```{r include=FALSE, eval=FALSE}
#Each score of DNA modification matrix
beta <- getBeta(MSet.swan)

#Saving data to file
beta_matrix_file <- '../data/GSE112179_beta_matrix.rds'
saveRDS(beta, file=beta_matrix_file)

#Information about main matrix samples (columns)
pdata <- pData(MSet.swan)

#Saving data to file
pdata_file <- '../data/GSE112179_pdata.rds'
saveRDS(pdata, file=pdata_file)

#Information about main matrix positions (rows)
anot <- getAnnotation(MSet.swan)

#Saving data to file
anot_file <- '../data/GSE112179_anot.rds'
saveRDS(anot, file=anot_file)
```

The DNA modification score matrix was generated and was saved as well as the 
information about main matrix samples and information about main matrix 
positions into files for later manipulations with the data.

\pagebreak
 
## Interarray correlation outliers elimination

Identification and removal of samples with divergent modification scores.

```{r include=FALSE, eval=FALSE}
#Calculating IACs for all pairs of samples
IAC_matrix = cor(beta, use="p")

#Histogram for outliers examination
hist(IAC_matrix, main = "Histogram of pair-to-pair inter-array correlation",
     xlab = "Inter-array correlations")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./1.png}
    \includegraphics[width=75mm]{./2.png}
    \caption{
    The correlation histogram (left) and scatter plot (right) to detect the 
    outliers for elimination
    }
  \end{center}
\end{figure}

The histogram (Figure 1) identifies that our dataset contains values which 
distort the overall distribution.
For further investigation, standard deviation from mean in each sample was 
calculated.

```{r include=FALSE, eval=FALSE}
#Mean for each column
mean_IAC <- apply(IAC_matrix,2,mean)

#Calculating standard deviation for data
SDev <- sd(mean_IAC) 

#From each column mean substracting all data mean and dividing by standard deviation
column_sd <- (mean_IAC-mean(mean_IAC))/SDev

#Ploting each column result
plot(column_sd, main = "Scatter plot of each sample standard deviation from mean",
     xlab = "Sample", ylab = "Deviation") 

#selecting boundary
abline(h=-3)
```

Scatter plot of each sample (column) (Figure 1) standard deviation from mean
visually highlights the data outliers (under -3 limit of deviation).

```{r include=FALSE, eval=FALSE}
limit <- -3
outliers <- dimnames(beta)[[2]][column_sd<limit]
#removing outliers
beta <- beta[,!(column_sd<limit)]
MSet.swan <- MSet.swan[,!(colnames(MSet.swan) %in% outliers)]
#Selecting IDs of outliers
```

Algorithm identified and removed 3 outliers: 

- GSM3059462_200590490031_R08C01 - a control sample of 53-year-old male
- GSM3059520_200357150067_R08C01 - a sample of a 56-year-old male with bipolar 
  disorder
- GSM3059454_200590490031_R01C01 - a sample of a 77-year-old female with 
  schizophrenia

```{r include=FALSE, eval=FALSE}
#Calculating IACs for all pairs of samples
IAC_matrix <- cor(beta, use="p")

#Histogram for outliers examinatiot
hist(IAC_matrix, ,  main = "Histogram of pair-to-pair inter-array correlation (Second)",
     xlab = "Inter-array correlations")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./3.png}
    \includegraphics[width=75mm]{./4.png}
    \caption{
      The correlation histogram (left) and scatter plot (right) of all dataset 
      after the elimination of outliers
    }
  \end{center}
\end{figure}

There is a visible difference on the left side of the histogram (Figure 2) 
compared to the histogram before the removal of outliers (Figure 1). This 
change indicated that the distorting values were removed correctly.

```{r include=FALSE, eval=FALSE}
#Mean for each column
mean_IAC <- apply(IAC_matrix,2,mean)
#Calculating standard deviation for data
SDev <- sd(mean_IAC) 
#From each column mean substracting all data mean and dividing by standard deviation
column_sd <- (mean_IAC-mean(mean_IAC))/SDev
#Ploting each column result
plot(column_sd, main = "Scatter plot of each sample standard deviation from 
     mean (Second)", xlab = "Sample", ylab = "Deviation") 
#selecting boundary
abline(h=-3)
```

No outliers were left in the recalculated scatter plot (Figure 2).

\newpage

## Quality control

After all data manipulations, our set has 97 samples with 858083 positions.

```{r include=FALSE, eval=FALSE}
control_pos <- list()
case_pos <- list()

#Separating control and case id's
for(index in 1:length(colnames(MSet.swan))) {
  if(MSet.swan$diagnosis[index] == "control"){
    control_pos[[length(control_pos)+1]] <- colnames(MSet.swan)[index]
  } else {
    case_pos[[length(case_pos)+1]] <- colnames(MSet.swan)[index]
  }
}

#Saving separated case and control data 
MSet.swan_control <- MSet.swan[,(colnames(MSet.swan) %in% control_pos)]
MSet.swan_case <- MSet.swan[,(colnames(MSet.swan) %in% case_pos)]
```

Data for quality control was separated into case (65 samples) and control 
(32 samples). Our main goal is to check if distortions in the methylation data 
exist.
 
```{r include=FALSE, eval=FALSE}
#Obtaining methylation estimates for case and control data separately
meth_control <- getMeth(MSet.swan_control)
meth_case <- getMeth(MSet.swan_case)
```

```{r include=FALSE, eval=FALSE}
#Calculating pair-to-pair correlation in control data
cor_control <- cor(meth_control, use = "p")
hist(cor_control, main = "Histogram of pair-to-pair inter-array correlation in 
     control samples", xlab = "Inter-array correlations")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./5.png}
    \includegraphics[width=75mm]{./7.png}
    \caption{
      The pair-to-pair correlation histogram (left) and scatter plot (right) for 
      control samples
    }
  \end{center}
\end{figure}

The histogram (Figure 3) represents a pair-to-pair correlation in control 
methylation data.

```{r include=FALSE, eval=FALSE}
mean_control <- apply(cor_control,2,mean)
#Calculating standard deviation for data
SDev <- sd(mean_control) 
#From each column mean substracting all data mean and dividing by standard deviation
column_sd <- (mean_control-mean(mean_control))/SDev
#Ploting each column result
plot(column_sd, main = "Scatter plot of each sample standard deviation from mean
     in control samples", xlab = "Sample", ylab = "Deviation")  
```

We can indicate both from histogram and scatter plot (Figure 3) that 
data is distributed normally and there is no need for data removal.

```{r include=FALSE, eval=FALSE}
cor_case <- cor(meth_case, use = "p")
hist(cor_case, main = "Histogram of pair-to-pair inter-array correlation in 
     case samples", xlab = "Inter-array correlations")
```

Sequentially, it was decided to check the distribution of case methylation data.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./6.png}
    \includegraphics[width=75mm]{./8.png}
    \caption{
      The pair-to-pair correlation histogram (left) and scatter plot (right) of 
      all case samples
    }
  \end{center}
\end{figure}

The scatter plot (Figure 4) of all case samples indicates, that our data has 
distorted values in respect of all case samples mean. It demonstrates two 
outliers in standard deviation from methylation mean. For further analysis we 
separated case data into "bipolar" and "schizophrenia" cases.

```{r include=FALSE, eval=FALSE}
mean_case <- apply(cor_case,2,mean)
#Calculating standard deviation for data
SDev <- sd(mean_case) 
#From each column mean substracting all data mean and dividing by standard deviation
column_sd <- (mean_case-mean(mean_case))/SDev
#Ploting each column result
plot(column_sd, main = "Scatter plot of each sample standard deviation from mean
     in case samples", xlab = "Sample", ylab = "Deviation") 
```

```{r include=FALSE, eval=FALSE}
case_bipolar <- list()
case_schi <- list()
#Separating data into "bipolar" and "schizophrenia"
for(index in 1:length(colnames(MSet.swan))) {
  if(MSet.swan$diagnosis[index]== "bipolar"){
    case_bipolar[[length(case_bipolar)+1]] <- colnames(MSet.swan)[index]
  } else if(MSet.swan$diagnosis[index]== "schizophrenia"){
    case_schi[[length(case_schi)+1]] <- colnames(MSet.swan)[index]
  }
}

#Saving separated cases
MSet.swan_bipol <- MSet.swan[,(colnames(MSet.swan) %in% case_bipolar)]
MSet.swan_schi <- MSet.swan[,(colnames(MSet.swan) %in% case_schi)]
```

```{r include=FALSE, eval=FALSE}
#Obtaining methylation estimates for both cases
meth_bipol <- getMeth(MSet.swan_bipol)
meth_schi <- getMeth(MSet.swan_schi)

#Calculating pair-to-pair correlation
cor_bipolar <- cor(meth_bipol, use = "p")
cor_schi <- cor(meth_schi, use = "p")
```

```{r include=FALSE, eval=FALSE}
mean_case <- apply(meth_bipol,2,mean)
#Calculating standard deviation for data
SDev <- sd(mean_case) 
#From each column mean substracting all data mean and dividing by standard deviation
column_sd <- (mean_case-mean(mean_case))/SDev
#Ploting each column result
plot(column_sd, main = "Scatter plot of each sample standard deviation from mean
     in case of bipolar disorder samples", xlab = "Sample", ylab = "Deviation") 
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=90mm]{./9.png}
    \caption{
      The scatter plot of the bipolar samples
    }
  \end{center}
\end{figure}

The scatter plot (Figure 5) with bipolar cases does not show any big 
fluctuations from the mean methylation value of bipolar disorder case samples.

```{r include=FALSE, eval=FALSE}
mean_case <- apply(meth_schi,2,mean)
#Calculating standard deviation for data
SDev <- sd(mean_case) 
#From each column mean substracting all data mean and dividing by standard deviation
column_sd <- (mean_case-mean(mean_case))/SDev
#Ploting each column result
plot(column_sd, main = "Scatter plot of each sample standard deviation from mean
     in case of schizophrenia samples", xlab = "Sample", ylab = "Deviation")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=90mm]{./10.png}
    \caption{
      The scatterplot of the schizophrenia case samples
    }
  \end{center}
\end{figure}

The scatter plot (Figure 6) of schizophrenia cases also does not show any wide 
variations from the mean methylation value.

These separated data cases indicated that there is no need to remove any 
samples.

```{r include=FALSE, eval=FALSE}

qc <- getQC(MSet.swan)
addQC(MSet.swan, qc)
plotQC(qc)
```

Additionally, the sample-specific quality control for methylation data with 
getQC, addQC, and plotQC functions was estimated.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=90mm]{./11.png}
    \caption{
      The plot of quality control with getQC, addQC, and plotQC functions
    }
  \end{center}
\end{figure}

PlotQC plot (Figure 7) demonstrates that bad samples do not exist in our data 
set.

```{r include=FALSE, eval=FALSE}
#Simple density plot
groups <- MSet.swan$diagnosis
densityPlot(beta, sampGroups=groups, main = "Density of methylation intensity
            by different diagnosis groups"))

#Density plot of mean values
means_bipol <- rowMeans(getBeta(MSet.swan_bipol))
means_schi <- rowMeans(getBeta(MSet.swan_schi))
means_control <- rowMeans(getBeta(MSet.swan_control))
mean_values <- matrix(c(means_bipol, means_schi, means_control), ncol = 3)
colnames(mean_values) <- c("bipolar", "Schizophrenia", "control")
groups <- c("bipolar", "schizophrenia", "control")
densityPlot(mean_values, sampGroups=groups, main = "Density of methylation intensity
            by different diagnosis groups (position means)" )
```

Comparison of methylation in density plots (Figure 8) indicates high data quality
because no notable deviations are visible from the rest of the samples. Also 
significant alterations between different diagnosis are not present.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./12.png}
    \includegraphics[width=75mm]{./13.png}
    \caption{
      The density plot of methylation intensity of each sample(left) and 
      density plot of all samples positions mean methylation intensity (right)
    }
  \end{center}
\end{figure}

## Saving data

```{r include=FALSE, eval=FALSE}
saveRDS(MSet.swan, file='GSE112179_clear.rds')
```

Data was saved into *GSE112179_clear.rds* file after the processing.

# Data clustering

```{r include=FALSE, eval=FALSE}
# Packages needed

#BiocManager::install('GO.db')
#BiocManager::install('impute')
#BiocManager::install("WGCNA")
```

```{r include=FALSE, eval=FALSE}
# Loading needed packages
library(knitr)
library(RColorBrewer)
library(WGCNA)
library(ggplot2)
```

```{r include=FALSE, eval=FALSE}
# Loading prepared data for further analysis
beta <- readRDS(file='../data/GSE112179_beta_matrix.rds')

# Removing left-over samples from beta matrix
beta <- beta[, colnames(beta) != "GSM3059462_200590490031_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059520_200357150067_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059454_200590490031_R01C01"]

# Validation that there are 858083 positions and 97 samples
dim(beta)

sample_annot <- readRDS(file='../data/GSE112179_clear.rds')
```

```{r include=FALSE, eval=FALSE}
# Removing left-over samples from beta matrix
beta <- beta[, colnames(beta) != "GSM3059462_200590490031_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059520_200357150067_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059454_200590490031_R01C01"]

# Validation that there are 858083 positions and 97 samples
dim(beta)
```

```{r include=FALSE, eval=FALSE}
# Calculation of distance matrix. `dist` function could not be used due to 
# 'vector memory exhausted (limit reached?)' error message.

num_samples <- 97
num_positions <- 858083

dist_m <- matrix(0, nrow=num_samples, ncol=num_samples)

# Iterating through samples (a)
for(i in 1:num_samples) {
  begin <- (i-1)*num_positions+1
  end <- i*num_positions
  a <- c(beta[begin:end])
  
  # Iterating through remaining samples
  for(j in i:num_samples) {
    
    if(i != j) {
      begin_b <- (j-1)*num_positions+1
      end_b <- j*num_positions
      b <- c(beta[begin_b:end_b])
    
      dist_m[i,j] <- 1 - cor(a, b)
    } else {
      dist_m[i,j] <- 0
    }
  }
}
```

```{r include=FALSE, eval=FALSE}
# Saving calculations
dist_m_file <- '../data/GSE112179_dist_matrix.rgcs'
saveRDS(dist_m, file=dist_m_file)
```

```{r include=FALSE, eval=FALSE}
dist_m <- readRDS(file=dist_m_file)
```

```{r include=FALSE, eval=FALSE}
# Making matrix symmetric
dist_m[lower.tri(dist_m)] <- t(dist_m)[lower.tri(dist_m)]
```

```{r include=FALSE, eval=FALSE}
# Constructing more explanatory sample names
dendrogram_names <- c()
for(i in 1:length(sample_annot@colData$id)) {
  sample_name <- paste(sample_annot@colData$diagnosis[i],
    sample_annot@colData$sex[i],
    sample_annot@colData$age[i],
    sample_annot@colData$race[i],
    sample_annot@colData$pmi[i],
    sep='_')
  dendrogram_names <- append(dendrogram_names, sample_name)
}
```


```{r include=FALSE, eval=FALSE}
# Saving sample names for cluster plotting

rownames(dist_m) <- dendrogram_names
colnames(dist_m) <- dendrogram_names
```

For the second task it was required to perform data clustering, which was 
performed using `hclust` function with `ward.d` linkage
method. This method takes into account variance of the clusters, thus it is 
considered to be the most eligible method for quantitative data sets.

```{r include=FALSE, eval=FALSE}
# Performing clusterisation 
clustered <- hclust(as.dist(dist_m), method="ward.D")
```

```{r include=FALSE, eval=FALSE}
# Plotting dendrogram

colors_cases <- c()
for(i in 1:length(sample_annot@colData$diagnosis)) {
  if(sample_annot@colData$diagnosis[i] == 'control') {
    # control - pink
    colors_cases <- append(colors_cases, '#FFB6B6')
  }
  if(sample_annot@colData$diagnosis[i] == 'bipolar') {
    # bipolar - blue
    colors_cases <- append(colors_cases, '#0000FF')
  }
  if(sample_annot@colData$diagnosis[i] == 'schizophrenia') {
    # schizophrenia - red
    colors_cases <- append(colors_cases, '#FF0000')
  }
}

colors_sex <- c()
for(i in 1:length(sample_annot@colData$sex)) {
  if(sample_annot@colData$sex[i] == 'female') {
    # female - red
    colors_sex <- append(colors_sex, '#FF0000')
  }
  if(sample_annot@colData$sex[i] == 'male') {
    # male - blue
    colors_sex <- append(colors_sex, '#0000FF')
  }
}

colors_age <- c()
for(i in 1:length(sample_annot@colData$age)) {
  if(sample_annot@colData$age[i] < 41) {
    # age group - 23-40 - red
    colors_age <- append(colors_age, '#FF0000')
  }
  if(sample_annot@colData$age[i] >= 41 && sample_annot@colData$age[i] < 59) {
    # age group - 41-58 - purple
    colors_age <- append(colors_age, '#7D7DFF')
  }
  if(sample_annot@colData$age[i] >= 59) {
    # age group - 60-77 - blue
    colors_age <- append(colors_age, '#0000FF')
  }
}

colors_race <- c()
for(i in 1:length(sample_annot@colData$race)) {
  if(!is.na(sample_annot@colData$race[i])){
    if(sample_annot@colData$race[i] == 'white') {
      # white race - red
      colors_race <- append(colors_race, '#FF0000')
    }
    if(sample_annot@colData$race[i] == 'hispanic') {
      # hispanic race - purple
      colors_race <- append(colors_race, '#7D7DFF')
    }
    if(sample_annot@colData$race[i] == 'black') {
      # black race - blue
      colors_race <- append(colors_race, '#0000FF')
    }
  } else {
    colors_race <- append(colors_race, '#FFFFFF')
  }
}

colors_pmi <- c()
for(i in 1:length(sample_annot@colData$pmi)) {
  if(!is.na(sample_annot@colData$pmi[i])){
    if(sample_annot@colData$pmi[i] < 11) {
      # red
      colors_pmi <- append(colors_pmi, '#FF0000')
    }
    if(sample_annot@colData$pmi[i] >= 11 && sample_annot@colData$pmi[i] < 18) {
      # pink
      colors_pmi <- append(colors_pmi, '#FFB6B6')
    }
    if(sample_annot@colData$pmi[i] >= 18 && sample_annot@colData$pmi[i] < 25) {
      # purple
      colors_pmi <- append(colors_pmi, '#7D7DFF')
    }
    if(sample_annot@colData$pmi[i] >= 25 && sample_annot@colData$pmi[i] < 32) {
      # dark purple
      colors_pmi <- append(colors_pmi, '#5858FF')
    }
    if(sample_annot@colData$pmi[i] >= 32) {
      # blue
      colors_pmi <- append(colors_pmi, '#0000FF')
    }
  } else {
    colors_pmi <- append(colors_pmi, '#FFFFFF')
  }
}
length(colors_pmi)

colors_m <- cbind(colors_sex, colors_cases, colors_race, colors_age, colors_pmi)

plotDendroAndColors(clustered, colors_m, 
                    main="Dendrogram of samples' clustering",
                    groupLabels=c('sex', 'case', 'race', 'age', 'PMI'),
                    colorHeightBase=0.05,
                    cex.dendroLabels=0.75,
                    cex.colorLabels=1,
                    cex.lab=0.75,
                    cex.main=1)
```
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./14.png}
    \caption{
      The dendrogram that shows three clusters after the hierarchical clustering
      using 1-cor() distance metric and Ward linkage method
    }
  \end{center}
\end{figure}

The dendrogram (Figure 9) shows three distinguished groups after clusterisation.
It is worth noting that NA values are marked as white color (such examples can
be observed in race and post-mortem interval (PMI) colouring)

Clusters were analysed with the respect of sex, case, race, age, and PMI
features. The main two clusters were distinguished based on sex. Within
these two main clusters, samples were grouped into three smaller clusters.

The first (female) cluster is composed of 24 samples. This collection contains 
15 samples of bipolar, 6 samples of schizophrenia, and 3 samples of control 
cases.

Second and third groups are found within male cluster separated from the first 
group. It is made of 29 samples, of which 8 are control, 8 are bipolar, and 13 
are schizophrenia cases.

Meanwhile, the third group has got 44 samples: 21 belong to control, 8 to 
bipolar, and 15 to schizophrenia cases.

Regarding these clustering results, it could be stated that besides the feature
of sex, there are no significant clusters for further investigation. If we 
compared numbers of each case within each cluster, we could state that the 
biggest portion of the first cluster is bipolar (15/24), of the second - 
schizophrenia (13/29), and the third - control samples (21/44), however only the
bipolar cases in the first cluster make up more than a half of the cluster 
samples. Presumably, if more samples were included in the analysis, more 
confident statements could be made regarding clustering of methylation data.

The majority of samples had race 'white' (marked red).
Race 'hispanic' is marked with a purple colour, and race 'black' is 
marked with blue colour. Due to the visible imbalance, clusterisation 
analysis in regards of 'race' feature cannot give any strong conclusions.

There are 3 age intervals that are noted with colours from red to blue: 
23-40, 41-58, 59-77. The biggest cluster of the first age group
can be observed within female samples. This cluster is composed of bipolar and
schizophrenia case samples. Another more significant cluster can be observed
within males of the middle age group. This cluster is composed of all cases, 
however the majority of cases are schizophrenic. The samples of the last age 
group can be found in all three clusters of the dendrogram.

The post-mortem interval colouring (from youngest to oldest colour changes from 
red to blue) shows that most of the samples were collected within 18 time units 
after death (red, pink, and purple colors). 

```{r include=FALSE, eval=FALSE}
# Collecting sample indeces for cluster analysis
cluster_1_indeces <- clustered$order[1:24]
cluster_2_indeces <- clustered$order[25:53]
cluster_3_indeces <- clustered$order[54:97]
```

```{r include=FALSE, eval=FALSE}
sample_annot@colData$diagnosis[cluster_1_indeces]
sample_annot@colData$diagnosis[cluster_2_indeces]
sample_annot@colData$diagnosis[cluster_3_indeces]

# Numeration of clusters is from left to right

# Analysis of the first cluster
cluster_1_control <- sum(sample_annot@colData$diagnosis[cluster_1_indeces] == 
                    "control")
cluster_1_bipolar <- sum(sample_annot@colData$diagnosis[cluster_1_indeces] == 
                    "bipolar")
cluster_1_schizo <- sum(sample_annot@colData$diagnosis[cluster_1_indeces] == 
                   "schizophrenia")

# Analysis of the second cluster
cluster_2_control <- sum(sample_annot@colData$diagnosis[cluster_2_indeces] == 
                    "control")
cluster_2_bipolar <- sum(sample_annot@colData$diagnosis[cluster_2_indeces] == 
                    "bipolar")
cluster_2_schizo <- sum(sample_annot@colData$diagnosis[cluster_2_indeces] == 
                   "schizophrenia")

# Analysis of the third cluster
cluster_3_control <- sum(sample_annot@colData$diagnosis[cluster_3_indeces] == 
                    "control")
cluster_3_bipolar <- sum(sample_annot@colData$diagnosis[cluster_3_indeces] == 
                    "bipolar")
cluster_3_schizo <- sum(sample_annot@colData$diagnosis[cluster_3_indeces] == 
                   "schizophrenia")
```

# Heatmap plotting

The second part of the second task was to provide heatmaps for the most varying
positions in the data set. The variability of each position 
was measured by calculating its variance within the samples.

```{r include=FALSE, eval=FALSE}
# Calculation of variance (long lasting calculation)
variances <- c()
for(i in 1:length(beta[,1])) {
  variances <- append(variances, var(beta[i,]))
}

length(variances)
```

```{r include=FALSE, eval=FALSE}
# Saving calculations
saveRDS(variances, file='../data/GSE112179_beta_variances.rgcs')
```

```{r include=FALSE, eval=FALSE}
variances <- readRDS(file='../data/GSE112179_beta_variances.rgcs')
```

Resources were not effective to reflect all modification positions in heatmap. 
Therefore, top 100 positions were selected with highest variances to picture
data in heatmap.

```{r include=FALSE, eval=FALSE}
# Picking top N positions to plot in the heatmap
library(gplots)

heatmap_beta <- beta
colnames(heatmap_beta) <- dendrogram_names

ordered <- order(-variances)
N <- 100
top_N_positions <- ordered[1:N]

top_N_beta <- cbind(heatmap_beta[top_N_positions,cluster_1_indeces], 
                    heatmap_beta[top_N_positions,cluster_2_indeces],
                    heatmap_beta[top_N_positions,cluster_3_indeces])

lwid=c(0.2,0.5) 
lhei=c(0.1,0.2) 

heatmap.2(top_N_beta, scale = "none", col=bluered(100), 
          trace="none", 
          lwid=lwid,
          lhei=lhei,
          margins=c(11,5),
          key.title='Colour key')
```

For comparison, selected data was standardized so that positions would have 
modification mean 0 and standard deviation 1.

```{r include=FALSE, eval=FALSE}
# Standardizing the values of positions
top_N_beta_z <- top_N_beta

for(i in 1:length(top_N_beta[,1])) {
  top_N_beta_z[i,] <- (top_N_beta[i,]-mean(top_N_beta[i,]))/sd(top_N_beta[i,])
}

heatmap.2(top_N_beta_z, scale = "none", col = bluered(100), 
          trace="none", 
          lwid=lwid,
          lhei=lhei,
          margins=c(11,5),
          key.title='Colour key')
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./Not_standartized.png}
    \caption{
      The heatmap of top 100 most variable modification positions with not 
      standardized data
    }
  \end{center}
\end{figure}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./Standartized.png}
    \caption{
      The heatmap of top 100 most variable modification positions
      with standardized data
    }
  \end{center}
\end{figure}

Generated heatmaps indicate that no significant data clustering is visible
in our data set. It can be seen that the values were more evenly 
distributed after the standardization of the data, but this information did
not reveal any important data areas, which would be important to investigate.

Several areas show more significant similarities as replicas are compared.

## Heatmap plotting with replicas removed

Due to the similarity of the replicas, they were removed from the
dataset and recalculations of variability was performed.

```{r include=FALSE, eval=FALSE}
library(stringr)

unique_samples <- c()
beta_uniq <- beta
length(colnames(beta_uniq))
colnames(beta_uniq) <- dendrogram_names
basenames_to_remove <- c()

for(i in 1:length(colnames(beta))) {
  print(paste(i, sample_name))
  sample_name <- dendrogram_names[i]
  if(!(sample_name %in% unique_samples)) {
    unique_samples <- append(unique_samples, sample_name)
  } else {
    basenames_to_remove <- append(basenames_to_remove, colnames(beta)[i])
  }
}

beta_uniq <- beta[, !colnames(beta) %in% basenames_to_remove]
```

```{r include=FALSE, eval=FALSE}
# Calculation of variance (long lasting calculation)
variances_no_rep <- c()
for(i in 1:length(beta_uniq[,1])) {
  print(i)
  variances_no_rep <- append(variances_no_rep, var(beta_uniq[i,]))
}

length(variances_no_rep)
```

```{r include=FALSE, eval=FALSE}
# Saving calculations
saveRDS(variances_no_rep, file='../data/GSE112179_beta_no_replicas_variances.rgcs')
```

```{r include=FALSE, eval=FALSE}
variances_no_rep <- readRDS(file='../data/GSE112179_beta_no_replicas_variances.rgcs')
```

```{r include=FALSE, eval=FALSE}
# Picking top N positions to plot in the heatmap after replicas were removed
heatmap_beta <- beta_uniq
colnames(heatmap_beta) <- unique_samples

ordered <- order(-variances_no_rep)
N <- 100
top_N_positions <- ordered[1:N]

top_N_beta <- cbind(heatmap_beta[top_N_positions,])

lwid=c(0.2,0.5) 
lhei=c(0.1,0.2) 

heatmap.2(top_N_beta, scale = "none", col=bluered(100), 
          trace="none", 
          lwid=lwid,
          lhei=lhei,
          margins=c(11,5),
          key.title='Colour key')
```

```{r include=FALSE, eval=FALSE}
# Standardizing the values of positions
top_N_beta_z <- top_N_beta

for(i in 1:length(top_N_beta[,1])) {
  top_N_beta_z[i,] <- (top_N_beta[i,]-mean(top_N_beta[i,]))/sd(top_N_beta[i,])
}

heatmap.2(top_N_beta_z, scale = "none", col = bluered(100), 
          trace="none", 
          lwid=lwid,
          lhei=lhei,
          margins=c(11,5),
          key.title='Colour key')
```
After the recalculations, it is not possible to draw any additional conclusions
in the heatmap, as no additional clusters have emerged.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./rep_not_st.png}
    \caption{
      The heatmap of top 100 most variable modification positions with not 
      standardized data after replicas removal
    }
  \end{center}
\end{figure}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./rep_st.png}
    \caption{
      The heatmap of top 100 most variable modification positions
      with standardized data after replicas removal
    }
  \end{center}
\end{figure}

\newpage

# Clocks of DNA modification

The third part of the second task requires to predict age of patients from which
the samples were taken and compare predictions with the real data. Furthermore,
the next step for the analysis is to check, whether there is a significant 
difference of predicted age within each experimental group.

```{r include=FALSE, eval=FALSE}
# Installing required packages

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("methylclockData")
#BiocManager::install("methylclock")
```

```{r include=FALSE, eval=FALSE}
library(methylclockData)
library(methylclock)
```

Firstly, it was checked, which methylation clocks can be computed for the given 
data set if the threshold is set to be 80 percent (as default) of required CpGs 
to compute each clock.

It was checked with `checkClocks` and `DNAmAge` functions that the only clock 
which could not be computed for the given data set was Bayesian Neural Network 
(BNN) [@alfonso2020bayesian] (`DNAmAge` without age acceleration 
provided NAs in the output for each sample).

Finally, four methylation clocks were chosen for further workflow: Horwath,
Hannum, Levine, and PedBE. Generally, these clocks were chosen because they 
were computed for the given data set and they predict chronological DNAm age in 
years. Horvath's clock was trained on samples from 
various tissues, thus it
is a universal choice for any kind of samples. Hannum's clock was trained
on blood samples. Nonetheless the tissue type does not match the neural one, 
from which our data set samples were taken, blood is often taken as an indicator 
of the state of the whole organism, thus it was decided to include this clock in
the workflow. The same considerations can be applied to support the choice of 
Levine's clock. 

Horvath's skin and blood clock was removed due to its incompatibility with the
tissue type of our data set and its poor performance (\(R^2=0.51\)). On the
contrary PdeBE clock was kept, since it explained the most of variability
(\(R^2=0.75\)) in the data set when compared to other clocks, nonetheless the 
clock was trained on buccal epithelial swabs from patients 0-20 years old
(Figure 12).

```{r include=FALSE, eval=FALSE}
missing <- checkClocks(beta)
missing
predicted_age <- DNAmAge(beta)
predicted_age

pred_vs_real <- DNAmAge(beta, age=sample_annot@colData$age)
pred_vs_real
```

```{r include=FALSE, eval=FALSE}
plotDNAmAge(pred_vs_real$Horvath, sample_annot@colData$age,
            tit="Horvath's method")
```

```{r include=FALSE, eval=FALSE}
plotDNAmAge(pred_vs_real$Hannum, sample_annot@colData$age, 
            tit="Hannum's method")
```

```{r include=FALSE, eval=FALSE}
plotDNAmAge(pred_vs_real$Levine, sample_annot@colData$age, 
            tit="Levine's method")
```

```{r include=FALSE, eval=FALSE}
plotDNAmAge(pred_vs_real$PedBE, sample_annot@colData$age, 
            tit="PedBE method")
```

```{r include=FALSE, eval=FALSE}
plotDNAmAge(pred_vs_real$skinHorvath, sample_annot@colData$age, 
            tit="SkinHorvath's method")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./Horvath.png}
    \includegraphics[width=75mm]{./Hannum.png}
    \includegraphics[width=75mm]{./Levine.png}
    \includegraphics[width=75mm]{./PedBE.png}
    \caption{
    Correlation between biological age predicted by methylation clocks and the 
    chronological age
    }
  \end{center}
\end{figure}

To conclude analysis of the predicted and chronological age correlation, the 
best clocks were Hovarth's and PdeBE, which had \(R^2\) values equal to 0.74 and
0.75 respectively. The clock that had the worst accuracy was Levine's method 
that had \(R^2=0.25\), which means that only 25% of the variability observed in 
the target variable (chronological age) is explained by this model.

## Checking how predicted ages differ between experimental groups

The experimental groups (groups of interest) of our research are control, 
bipolar, and schizophrenia. Therefore, predicted age values will be analysed 
with regards of this kind of grouping of samples.

It was decided to run ANOVA tests for each methylation clock applied to
our data set. The null hypothesis was set to be that there is no difference 
between predicted biological age means of each case sample group.

- Data: predicted DNA methylation age.
- Test: ANOVA.
- Hipotheses:
\[H_0: \mu_1=\mu_2=\mu_3\]
\[H_1: \exists i,j\in\{1,2,3\}: i\neq j, \mu_i \neq \mu_j\]

- Significance level: \(\alpha=0.1\).

- \(p\) value \(> \alpha \rightarrow H_0\)
  not rejected.

```{r include=FALSE, eval=FALSE}
diagnoses <- sample_annot@colData$diagnosis

aov_Horvath <- aov(predicted_age$Horvath ~ diagnoses)
summary(aov_Horvath)

aov_Hannum <- aov(predicted_age$Hannum ~ diagnoses)
summary(aov_Hannum)

aov_Levine <- aov(predicted_age$Levine ~ diagnoses)
summary(aov_Levine)

aov_PedBE <- aov(predicted_age$PedBE ~ diagnoses)
summary(aov_PedBE)
```

p-values of each test: Horvath's 0.806, Hannum's 0.966, Levine's 0.994, 
PedBE 0.648.

None of the ANOVA tests had \(p\) value lower than \(\alpha\), therefore there 
are no differences in predicted biological age means between control, bipolar, 
and schizophrenic sample groups.

# Hypothesis testing

## Grouping data

It was decided to perform hypothesis testing for each 
position for samples grouped in a couple of different ways. In our case, we 
decided to define these groups based on sex and age.

```{r loading_data_3rd, include=FALSE, eval=FALSE}
# Loading prepared data for further analysis
beta <- readRDS(file='../data/GSE112179_beta_matrix.rds')

# Removing left-over samples from beta matrix
beta <- beta[, colnames(beta) != "GSM3059462_200590490031_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059520_200357150067_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059454_200590490031_R01C01"]

# Validation that there are 858083 positions and 97 samples
dim(beta)

sample_annot <- readRDS(file='../data/GSE112179_clear.rds')

# Loading position annotation data
pos_annot <- readRDS(file='../data/GSE112179_anot.rds')
```

```{r extracting_groups, include=FALSE, eval=FALSE}
sexes <- sample_annot@colData$sex
diagnoses <- sample_annot@colData$diagnosis
ages <- sample_annot@colData$age
```

## Normality testing

```{r normality_testing, include=FALSE, eval=FALSE}
# Performing normality test in order to pick the statistical test (t-test or
# Wilcoxon)
position_num <- length(beta[,1])

# Long-lasting calculations
shapiro_ps <- c()
for(i in 1:position_num) {
  print(i)
  shapiro_ps <- append(shapiro_ps, shapiro.test(beta[i,])$p.value)
}

length(shapiro_ps)
```

```{r analysis_shapiro_ps, include=FALSE, eval=FALSE}

lower_p_num <- 0
higher_p_num <- 0

alpha <- 0.05

for(i in 1:length(shapiro_ps)) {
  if(shapiro_ps[i] < 0.05) {
    lower_p_num <- lower_p_num + 1
  } else {
    higher_p_num <- higher_p_num + 1
  }
}

print(lower_p_num/length(shapiro_ps))
print(higher_p_num/length(shapiro_ps))
higher_p_num

rm(shapiro_ps)
```

Since there were more positions (554715 - up to 65% of all positions) that had 
p-value of Shapiro normality test 
higher than \(\alpha = 0.05\), it could be stated that the
majority of positions had normal data distribution, thus t-test was chosen for
further hypothesis testing.

## Hypothesis testing 

```{r hypothesis_testing_sex, include=FALSE, eval=FALSE}
# Tests will be performed for each row (position) in the data set
position_num <- length(beta[,1])

t_test_sex_ps <- c()
for(i in 1:position_num) {
  print(i)
  t_test_sex_ps <- append(t_test_sex_ps, t.test(beta[i,] ~ sexes)$p.value)
}

length(t_test_sex_ps)
t_test_sex_ps
```

```{r t_test_sex_ps_save, include=FALSE, eval=FALSE}
saveRDS(t_test_sex_ps, file='../data/GSE112179_t_test_sex_ps.rgcs')
```

```{r t_test_sex_ps_load, include=FALSE, eval=FALSE}
t_test_sex_ps <- readRDS(file='../data/GSE112179_t_test_sex_ps.rgcs')
```

The first hypothesis testing was performed to compare sample groups collected 
based on sex. Tests were run for each position in the data set.

- Data: methylation values of the position.
- Test: Student t-test.
- Hipotheses:
\[H_0: \mu_{i, male}=\mu_{i, female},\ where\ i\ -\ index\ of\ position\]
\[H_1: \mu_{i, male}\neq\mu_{i, female}\]

- Significance level: \(\alpha=0.05\).

```{r t_test_sex_ps_analysis, include=FALSE, eval=FALSE}
sum(t_test_sex_ps <= 0.05)
```

```{r t_test_sex_ps_hist, include=FALSE, eval=FALSE}
par(oma=c(0, 0, 2, 0))
hist(t_test_sex_ps, 
     xlim=c(0, 1), 
     breaks=80,
     ylim=c(0,40000),
     main='Histogram of t-test for gender groups p-values',
     xlab='p-value',
     cex.main=1.5)
abline(v=0.05,col="red")
text(x=0.1, y=35000, 'Alpha = 0.05')
```

The histogram of p-values (Figure 15) extracted from performed t-tests showed 
that there are approximately 80000 positions that have got statistically 
significant differences in methylation values between gender groups. Precisely, 
there were 76369 positions that had p-value lower than \(\alpha\).

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./t_test_sex_ps_hist.png}
    \caption{
    The histogram of p-values of t-test that compared sample groups of different
    sexes
    }
  \end{center}
\end{figure}

```{r t_test_sex_ps_top_5_plot_prep, include=FALSE, eval=FALSE}
t_test_sex_ps_top_5_idx <- order(t_test_sex_ps)[1:5]

t_test_sex_ps_top_5_methyl_profiles <- beta[t_test_sex_ps_top_5_idx,]
colnames(t_test_sex_ps_top_5_methyl_profiles) <- sexes
# male - 0
colnames(t_test_sex_ps_top_5_methyl_profiles)[colnames(t_test_sex_ps_top_5_methyl_profiles) == 'male'] <- 0
# female - 1
colnames(t_test_sex_ps_top_5_methyl_profiles)[colnames(t_test_sex_ps_top_5_methyl_profiles) == 'female'] <- 1
rownames(t_test_sex_ps_top_5_methyl_profiles)
```

Five positions that had the lowest p-values were: cg04462931, cg15183843, 
cg03572700, cg15228509, cg00399683. Their methylation profiles are presented
in Figure 16. In all of these positions methylation values in female group
were higher.

```{r t_test_sex_ps_top_5_plot, fig.height=3, fig.width=3, include=FALSE, eval=FALSE}
for(i in 1:5) {
  part_title <- paste('(', rownames(t_test_sex_ps_top_5_methyl_profiles)[i], 
                      ') methylation profile', sep='')
  plot(colnames(t_test_sex_ps_top_5_methyl_profiles), 
     (t_test_sex_ps_top_5_methyl_profiles)[i,], xaxt='n', 
     xlim=c(-0.5, 1.5), ylim=c(0,1),
     main=paste('Position', i, part_title),
     xlab='sample group',
     ylab='methylation values')
  axis(side=1, at=seq(0, 1, by=1), labels=c('male', 'female'))
}
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./t_test_sex_methyl_prof_1.png}
    \includegraphics[width=75mm]{./t_test_sex_methyl_prof_2.png}
    \includegraphics[width=75mm]{./t_test_sex_methyl_prof_3.png}
    \includegraphics[width=75mm]{./t_test_sex_methyl_prof_4.png}
    \includegraphics[width=75mm]{./t_test_sex_methyl_prof_5.png}
    \caption{
    Methylation profiles of positions with top 5 smallest p-values
    }
  \end{center}
\end{figure}

```{r include=FALSE, eval=FALSE}
rownames(t_test_sex_ps_top_5_methyl_profiles)

for(i in 1:5) {
  print(pos_annot[rownames(pos_annot) == 
              rownames(t_test_sex_ps_top_5_methyl_profiles)[i],]$chr)
}
```

These positions belong to chromosome 7 (cg04462931 and cg00399683), Y 
(cg15183843),
X (cg03572700), and 1 (cg15228509).

## Manhattan plot

Since there were two positions from chromosome 7, it was decided to draw a
Manhattan plot (Figure 17) with p-values of positions from this chromosome.

```{r collecting_chr7_pos, include=FALSE, eval=FALSE}
# Number of all positions in our data set from chromosome 7
length(rownames(pos_annot[pos_annot$chr == 'chr7',]))
chr7_position_names <- rownames(pos_annot[pos_annot$chr == 'chr7',])

# Long calculations
chr7_position_idx <- c()
for(i in 1:length(chr7_position_names)) {
  chr7_position_idx <- append(chr7_position_idx, 
                              which(rownames(beta) == chr7_position_names[i]))
}

# Names of positions 
chr7_position_names
# Indeces are used to get position's p-value from t_test_sex_ps vector
chr7_position_idx
# p-values of each position
chr7_position_ps <- t_test_sex_ps[chr7_position_idx]
```

```{r chr7_pos_idx_save, include=FALSE, eval=FALSE}
saveRDS(chr7_position_idx, file='../data/GSE112179_chr7_position_idx.rds')
```

```{r manhattan_plot_install, include=FALSE, eval=FALSE}
#BiocManager::install("GWASTools")
```

```{r manhattan_plot, include=FALSE, eval=FALSE}
library(GWASTools)
par(oma=c(1, 1, 1, 1))
manhattanPlot(-log10(chr7_position_ps), c(rep(7,length(chr7_position_ps))), 
              col=c(rep("dark blue", length(chr7_position_ps))),
              main='Manhattan plot of positions in chromosome 7')
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./chr7_Manhattan_plot.png}
    \caption{
     Manhattan plot for positions of chromosome 7
    }
  \end{center}
\end{figure}

## Volcano plot

```{r volcano_plot_install, include=FALSE, eval=FALSE}
#BiocManager::install("a4Base")
#install.packages('ggpointdensity')
```

```{r volcano_plot, include=FALSE, eval=FALSE}
library("a4Base")

male_beta_idx <- which(sexes == 'male')
female_beta_idx <- which(sexes == 'female')

effect_sizes <- rowMeans(beta[,male_beta_idx]) - 
  rowMeans(beta[,female_beta_idx])
effect_sizes

effect_sizes_p_values <- data.frame(x=effect_sizes, y=-log10(t_test_sex_ps))

volcano_plot_r <- plot(effect_sizes, -log10(t_test_sex_ps), xlab='effect size',
                       ylab='-log10 p-value', 
                       main='Volcano plot for all chromosomes',
                       col=c(rep("dark blue", length(effect_sizes))))
abline(h=-log10(0.05), col="red")

for(i in 1:5) {
  text(x=effect_sizes[t_test_sex_ps_top_5_idx[i]], 
       y=-log10(t_test_sex_ps[t_test_sex_ps_top_5_idx[i]])+1, 
       rownames(beta)[t_test_sex_ps_top_5_idx[i]])
}

```

The volcano plot shows several outliers that are downregulated in male samples
with respect of female samples and are statistically significant. Effect 
sizes of the top 5 most significant methylation values are given in the 
Table 1.

\begin{table}[h!]
    \begin{center}
		\caption{Effect sizes and p-values of the top 5 most significant positions
		of the sex-based test}
		\vspace{0.2cm}
    \begin{tabular}{ | c | c c c c c | }
      \hline
        Position & cg04462931 & cg15183843 & cg03572700 & cg15228509 & cg00399683 \\
        Effect size & -0.4456074 & -0.5868304 & -0.4042064 & -0.3516014 & -0.3066998 \\
        P-value & 8.155034e-114 & 5.494131e-106 & 5.754572e-101 & 6.004097e-98 & 2.974341e-93 \\
      \hline
    \end{tabular}
  \end{center}
  \label{table:ttestEffectP}
\end{table}

Since effect size values are all negative (all downregulated in male samples) 
they all are represented in the upper left part of the volcano plot. They appear
in the upper part of the plot due to small p-values.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./t_test_sex_volcano_plot_r.png}
    \caption{
     Volcano plot of all positions effect sizes and p-values of t-test for data 
     grouped to male and female groups
    }
  \end{center}
\end{figure}

## Correction of p-values

```{r include=FALSE, eval=FALSE}
library(stats)
```

### P-values from t-test for groups of sex

```{r t_test_ps_correction,  include=FALSE, eval=FALSE}
t_test_sex_ps_fdr <- p.adjust(t_test_sex_ps, "fdr")
sum(t_test_sex_ps_fdr <= 0.05)

t_test_sex_ps_bonf <- p.adjust(t_test_sex_ps, "bonferroni")
sum(t_test_sex_ps_bonf <= 0.05)
```

Number of statistically significant p-values (lower than \(\alpha=0.05\)):

- without correction: 76369
- with FDR correction: 21783
- with Bonferroni correction: 15237

## Gene Ontology Enrichment analysis after FDR correction

```{r go, include=FALSE, eval=FALSE}
foreground <- c()
background <- c()
indexes <- c()

#Selecting indexes of data after FDR correction
for(i in 1:position_num) {
  if(t_test_sex_ps_fdr[i] <= 0.05){
    indexes <- append(indexes, i)
  }
}

#Data correction for GOrilla input
foreground <- c(noquote(unique(gsub(";", " ",
                                    pos_annot$UCSC_RefGene_Name[indexes]))))
foreground <- unique(unlist(strsplit(foreground, " ")))
background <- c(noquote(unique(gsub(";", " ",pos_annot$UCSC_RefGene_Name))))
background <- unique(unlist(strsplit(background, " ")))

lapply(foreground, write, "foreground.txt", append=TRUE, ncolumns=1)
lapply(background, write, "background.txt", append=TRUE, ncolumns=1)
```

After all genes names manipulations, there were 10686 foreground genes selected
with FDR correction and 27304 background genes.

For gene ontology enrichment analysis we used GOrilla tool on statistically 
significant positions. 

In components part (Figure 19),
the highest enrichment is found in cellular components such as nucleus, 
cytoplasm, Golgi apparatus, and, notably, neuron parts (axon, neuronal cell 
body, dendrites, dendritic spines, synaptic membrane). These results reflect 
associations with samples of the isolated neurons from the prefrontal cortex. 

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./go_component_part.png}
    \caption{
    Components with the highest enrichment according to foreground and background 
    genes in GOrilla tool [@gorilla]
    }
  \end{center}
\end{figure}

In terms of processes (Figure 20), the highest enrichment is found
in a few main categories: regulation of metabolic processes, developmental
processes, and positive regulations of biological processes. The high values
highlighted in the diagram for regulation of neurogenesis
are one of the main indicators of data quality as they relate to the components
mentioned above. In metabolic processes it would be interesting to make
further investigation on regulation of kinase activity, transferase activity, 
and phosphate metabolic processes as there are only separate studies and traces 
of real possible intersections. Also, fascinating outcomes were found examining
prenatal errors of morphogenesis in patients with schizophrenia and bipolar
disorder [@TRIXLER2001195]. It was 
discovered, that patients have significantly higher rates of incorrect
morphogenesis compared to healthy patients, thus it indicates correlation with
developmental processes.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./go_process_part.png}
    \includegraphics[width=75mm]{./go_process_part_II.png}
    \caption{
    Processes with the highest enrichment according to foreground and background 
    genes in GOrilla tool
    }
  \end{center}
\end{figure}

Unsurprisigly, the highest enrichment among functions (Figure 21) is found in 
binding and catalytic activity, since the main function of neural cells is 
transmission of signals. 

The mechanisms that participate in the process of
signalling are ion (sodium, potassium, chloride, and calcium) binding, which is
apparent in the GOrilla output (Figure 21). Additionally, there is a nucleotide
binding seen in the scheme, which eventually leads to binding ATP function. 
Recent studies [@inoue2022role] investigate the 
role of ATP receptors in pain signaling. Furthermore, there are also literature 
resources [@li2019role] that analyse relations between the chronic pain and 
dopaminergic pathways. To extend this current research, it would be interesting
to explore, whether the cases of schizophrenia or bipolar disorder have got 
impact on pain signalling. Regarding to the published literature 
[@engels2014clinical, @stubbs2015prevalence], these psychiatric disorders do
include varied perception of pain, therefore it would be worthy to analyse
variations of methylation levels in the related genes.

Regarding the catalytic activity, it is known [@neve2004dopamine] that dopamine 
receptors are mediated by G proteins. G proteins activate cylic AMP-dependent 
protein kinase and protein phosphatase-1 inhibitor DARPP-32. Both kinase and 
phosphatase activities are included in the GO output. The mentioned knowledge
explains the enrichment observed in the GOrilla scheme. 

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./go_function_part.png}
    \includegraphics[width=75mm]{./go_function_part_catalytic.png}
    \caption{
    Functions with the highest enrichment according to foreground and background 
    genes in GOrilla tool
    }
  \end{center}
\end{figure}


## Hypothesis testing for groups of age

```{r hypothesis_testing_age, include=FALSE, eval=FALSE}
# Tests will be performed for each row (position) in the data set
position_num <- length(beta[,1])

aov_age_ps <- c()
for(i in 1:position_num) {
  print(i)
  mod0 <- lm(beta[i,] ~ sexes + diagnoses)
  mod1 <- lm(beta[i,] ~ ages + sexes + diagnoses)
  res <- anova(mod0, mod1)
  aov_age_ps <- append(aov_age_ps, unlist(res)['Pr(>F)2'])
}
length(aov_age_ps)
aov_age_ps[1]
saveRDS(aov_age_ps, file='GSE112179_aov_age_ps.rgcs')
```

The second hypothesis testing was performed to compare sample groups collected 
based on age (in groups of sexes and diagnoses). 
Tests were run for each position in the data set.

- Data: methylation values of the position.
- Test: ANOVA
- Hipotheses:
\[H_0: \mu_{i, sda}=\mu_{i, sd},\ where\ i\ -\ index\ of\ position,\ sda\ -\
sexes,\ ages\ and\ diagnoses,\ sd - sexes\ and\ diagnoses.\]
\[H_1: \mu_{i, sda}\neq\mu_{i, sd}\]

- Significance level: \(\alpha=0.05\).

```{r age_histogram, include=FALSE, eval=FALSE}

aov_age_ps <- readRDS(file='GSE112179_aov_age_ps.rgcs')

sum(aov_age_ps <= 0.05)


par(oma=c(0, 0, 2, 0))
hist(aov_age_ps, 
     xlim=c(0, 1), 
     breaks=80,
     ylim=c(0,100000),
     main='Histogram of ANOVA hypothesis testing for groups of age',
     xlab='p-value',
     cex.main=1.5)
abline(v=0.05,col="red")
text(x=0.1, y=35000, 'Alpha = 0.05')
```

The histogram of p-values (Figure 22) extracted from performed ANOVA test showed 
that there are more than 100000 positions that have got statistically 
significant differences in methylation values between groups with age and
without age. Precisely, there were 171830 positions that had p-value 
lower than \(\alpha\).

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./anova_age.png}
    \caption{
    The histogram of p-values of ANOVA test that compared sample sex and 
    diagnosis groups with and without age group
    }
  \end{center}
\end{figure}

```{r 5_top_idx, include=FALSE, eval=FALSE}
aov_age_ps_top_5_idx <- order(aov_age_ps)[1:5]

aov_age_ps_top_5_methyl_profiles <- beta[aov_age_ps_top_5_idx,]
colnames(aov_age_ps_top_5_methyl_profiles) <- ages
average_age <- round(sum(ages)/length(ages), digits=0)
# < 47 - 0
colnames(aov_age_ps_top_5_methyl_profiles)[colnames(aov_age_ps_top_5_methyl_profiles) < average_age] <- 0
# >= 47 - 1
colnames(aov_age_ps_top_5_methyl_profiles)[colnames(aov_age_ps_top_5_methyl_profiles) >= average_age] <- 1
rownames(aov_age_ps_top_5_methyl_profiles)


for(i in 1:5) {
  part_title <- paste('(', rownames(aov_age_ps_top_5_methyl_profiles)[i], 
                      ') methylation profile', sep='')
  plot(colnames(aov_age_ps_top_5_methyl_profiles), 
       (aov_age_ps_top_5_methyl_profiles)[i,], xaxt='n', 
       xlim=c(-0.5, 1.5), ylim=c(0,1),
       main=paste('Position', i, part_title),
       xlab='sample group',
       ylab='methylation values')
  axis(side=1, at=seq(0, 1, by=1), labels=c('age < 47', 'age >= 47'))
}


rownames(aov_age_ps_top_5_methyl_profiles)

for(i in 1:5) {
  print(pos_annot[rownames(pos_annot) == 
                    rownames(aov_age_ps_top_5_methyl_profiles)[i],]$chr)
}
```

Five positions that had the lowest p-values were: cg27026819, cg02426178, 
cg06220235, cg18514820, cg05191364. Their methylation profiles are presented
in Figure 23. In all of these positions methylation values in female group
were higher.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=75mm]{./pos_1.png}
    \includegraphics[width=75mm]{./pos_2.png}
    \includegraphics[width=75mm]{./pos_3.png}
    \includegraphics[width=75mm]{./pos_4.png}
    \includegraphics[width=75mm]{./pos_5.png}
    \caption{
    Methylation profiles of positions with top 5 smallest p-values in 
    hypothesis testing for groups of age
    }
  \end{center}
\end{figure}

These positions belong to chromosomes 6 (cg27026819 and cg05191364), 19 
(cg02426178), 16 (cg06220235), and 10 (cg18514820).

## Manhattan plot

Because the Manhattan plot in sex-based hypothesis testing was drawn for 
positions in 7th chromosome, for more detailed comparison, Manhattan plot was 
also created for the age-based test (Figure 24) with p-values of positions in 
this chromosome.

```{r chr7_age, include=FALSE, eval=FALSE}
chr7_position_idx <- readRDS(file='GSE112179_chr7_position_idx.rds')

# Names of positions 
chr7_position_names
# Indeces are used to get position's p-value from t_test_sex_ps vector
chr7_position_idx
# p-values of each position
chr7_position_ps <- aov_age_ps[chr7_position_idx]

library(GWASTools)
par(oma=c(1, 1, 1, 1))
manhattanPlot(-log10(chr7_position_ps), c(rep(7,length(chr7_position_ps))), 
              col=c(rep("dark blue", length(chr7_position_ps))),
              main='Manhattan plot of positions in chromosome 7')
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./manhatan.png}
    \caption{
     Manhattan plot for positions of chromosome 7 in hypothesis testing 
     for groups of age
    }
  \end{center}
\end{figure}

## Volcano plot

```{r volcano_ages, include=FALSE, eval=FALSE}
lower_47_idx <- which(ages < 47)
higher_47_idx <- which(ages >= 47)

effect_sizes <- rowMeans(beta[,lower_47_idx]) - 
  rowMeans(beta[,higher_47_idx])
effect_sizes

effect_sizes_p_values <- data.frame(x=effect_sizes, y=-log10(aov_age_ps))


volcano_plot <- ggplot(effect_sizes_p_values, aes_(x=effect_sizes_p_values$x, 
                                                   y=effect_sizes_p_values$y)) + 
  geom_point() + 
  geom_pointdensity() +
  scale_color_viridis() +
  xlab('effect size') + ylab('-log10 p-value') + 
  labs(title = 'Volcano plot for all chromosomes')

volcano_plot

volcano_plot_r <- plot(effect_sizes, -log10(aov_age_ps), xlab='effect size',
                       ylab='-log10 p-value', 
                       main='Volcano plot for all chromosomes',
                       col=c(rep("dark blue", length(effect_sizes))))
abline(h=-log10(0.05), col="red")

for(i in 1:5) {
  text(x=effect_sizes[aov_age_ps_top_5_idx[i]], 
       y=-log10(aov_age_ps[aov_age_ps_top_5_idx[i]])+1, 
       rownames(beta)[aov_age_ps_top_5_idx[i]])
}
```

The volcano plot (Figure 25) shows 4 outliers that are downregulated in samples 
with age younger than 47 years old and 1 outlier in samples with age older than 
47. Effect sizes of the top 5 most significant methylation values are given in
Table 2.

\begin{table}[h!]
    \begin{center}
		\caption{Effect sizes and p-values of the top 5 most significant positions 
		of the age-based test}
		\vspace{0.2cm}
    \begin{tabular}{ | c | c c c c c | }
      \hline
        Position & cg27026819  & cg02426178 & cg06220235 & cg18514820  & cg05191364  \\
        Effect size & -0.05352193 & 0.05711899  & -0.03063718 & -0.03572649  & -0.04990001  \\
        P-value & 5.756907e-29 & 1.751467e-27 & 1.158018e-25 & 2.889758e-25 & 1.185194e-24 \\
      \hline
    \end{tabular}
  \end{center}
  \label{table:anovaEffectP}
\end{table}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./volcano_age_fixed.png}
    \caption{
     Volcano plot of all positions effect sizes and p-values of ANOVA test for 
     data grouped to people younger than 47 years and older than 47 years 
    }
  \end{center}
\end{figure}

\pagebreak

# KNN regression to predict age

In order to train the knn model, it is required to have the training, 
validation, and testing data sets. However, this time cross-validation will be 
applied, thus the static division of the data set will not be applied.

```{r loading_data_4th, include=FALSE, eval=FALSE}
# Loading prepared data for further analysis
beta <- readRDS(file='../data/GSE112179_beta_matrix.rds')

# Removing left-over samples from beta matrix
beta <- beta[, colnames(beta) != "GSM3059462_200590490031_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059520_200357150067_R08C01"]
beta <- beta[, colnames(beta) != "GSM3059454_200590490031_R01C01"]

# Validation that there are 858083 positions and 97 samples
dim(beta)

sample_annot <- readRDS(file='../data/GSE112179_clear.rds')

# Loading position annotation data
pos_annot <- readRDS(file='../data/GSE112179_anot.rds')
```

```{r knn_implemented, include=FALSE, eval=FALSE}

knn_inference <- function(k, train_data, labels, point) {
  distances <- c() 
  for(j in 1:ncol(train_data)) {   
    # Finding (Euclidean) distances between the input point and all points in the 
    # training set.
    distance <- 0
    for(i in 1:nrow(train_data)) {
      distance <- distance + (point[i] - train_data[i, j])**2
    }
    distances <- append(distances, (distance)**(1/2))
  }
  
  # Sorting distances to get the nearest neighbours
  sorted_neighbours <- order(distances)
  
  # Summing up the labels of the nearest neighbours
  knn_label_sum <- 0
  for(i in 1:k) {
    knn_label_sum <- knn_label_sum + labels[sorted_neighbours[i]]
  }
  
  # Calculating mean of the nearest neighbours
  return(knn_label_sum/k)
}

```

```{r knn_trivial_usage_case, include=FALSE, eval=FALSE}
# Example (trivial case) usage of knn inference for our data

# Taking first m positions (should be adjusted to take only most varying 
# positions with respect of age) 
m <- 1000

# Taking first n points
n <- 50

# Index of an input point (to get knn "inference" - prediction)
l <- 51

train_data <- beta[1:m, 1:n]
labels <- sample_annot@colData$age[1:n]

point <- beta[1:m, l]

point_label_predicted <- knn_inference(k=5, train_data, labels, point)

print(paste('Predicted', point_label_predicted, 'vs real', 
            sample_annot@colData$age[l]))
```

# PCA analysis

In order to test the principal component analysis functionality, it was decided 
to perform a simple case of PCA: for groups of sex (since the grouping was 
obvious) and for only a subset of positions. The subset was 
chosen to be composed of approximately 10\% of all positions - 80000. The output
of principal component analysis (Figure 26) was the first principal component 
that explained 9.6\% of variance and the second principal component that 
explained 6.7\% of the set variance.

```{r pca_names, include=FALSE, eval=FALSE}
# Constructing more explanatory sample names
pca_names <- c()
for(i in 1:length(sample_annot@colData$id)) {
  sample_name <- paste(sample_annot@colData$diagnosis[i],
    sample_annot@colData$sex[i],
    sample_annot@colData$age[i],
    sample_annot@colData$race[i],
    #sample_annot@colData$pmi[i],
    sep='_')
  pca_names <- append(pca_names, sample_name)
}
```

Afterwards, it was decided to keep the same grouping of sex, though this time to
include all positions. The output of PCA (Figure 27) did not show a clear 
distinction of groups - female and male samples were mixed up in the output 
plot. The second attempt of PCA showed that the first principal component 
explained 11\% of the variance and the second one - 7.8\%. These percentages did 
not differ significantly from the output of the first PCA.

```{r pca_sex_subset, include=FALSE, eval=FALSE}
library(plyr)
library(dplyr)
library(ggbiplot)

# Based on: https://www.datacamp.com/tutorial/pca-analysis-r

samples <- 97
positions <- 80000

beta.pca.subset <- prcomp(t(beta)[1:samples, 1:positions], center=TRUE, 
                          scale=TRUE)
summary(beta.pca.subset)

ggbiplot(beta.pca.subset, ellipse=TRUE, obs.scale=1, var.scale=1,
         var.axes=FALSE,
         groups=sample_annot@colData$sex[1:samples]) +
         ggtitle("PCA for groups of sex using positions' subset")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./PCA_sex_subset.png}
    \caption{
     PCA for groups of sex including all samples and a subset (80000) of 
     positions
    }
  \end{center}
\end{figure}

```{r pca_sex_all, include=FALSE, eval=FALSE}
positions <- length(beta[,1])


beta.pca <- prcomp(t(beta)[1:samples, 1:positions], center=TRUE, scale=TRUE)

summary(beta.pca)

ggbiplot(beta.pca, ellipse=TRUE, obs.scale=1, var.scale=1,var.axes=FALSE,
         #labels=pca_names[1:samples], 
         groups=sample_annot@colData$sex[1:samples]) +
         ggtitle("PCA for groups of sex including all positions")
```

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=150mm]{./PCA_sex_all.png}
    \caption{
     PCA for groups of sex including all positions and all samples
    }
  \end{center}
\end{figure}



# References {-}
